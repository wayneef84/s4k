<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>S4K Mixer V2</title>
    <style>
        * { box-sizing: border-box; -webkit-tap-highlight-color: transparent; }
        
        body { 
            background: #0f0f1b; 
            color: white; 
            font-family: -apple-system, BlinkMacSystemFont, sans-serif; 
            text-align: center; 
            margin: 0; 
            padding: 10px; 
            padding-bottom: 120px;
            min-height: 100vh;
        }
        
        h1 { font-size: 1.5rem; margin: 10px 0 15px; }
        
        /* Controls - Big Touch Targets */
        .controls { 
            display: flex; 
            justify-content: center; 
            gap: 20px; 
            margin-bottom: 15px; 
        }
        .btn-ctrl { 
            width: 70px; 
            height: 70px; 
            border-radius: 50%; 
            border: none; 
            font-size: 2rem; 
            cursor: pointer; 
            display: flex; 
            align-items: center; 
            justify-content: center; 
            box-shadow: 0 4px 15px rgba(0,0,0,0.4);
            transition: transform 0.1s;
        }
        .btn-ctrl:active { transform: scale(0.92); }
        .btn-play { background: #2ecc71; color: white; }
        .btn-play.playing { background: #f39c12; }
        .btn-stop { background: #e74c3c; color: white; }
        
        /* Stage */
        .stage { 
            display: flex; 
            justify-content: center; 
            gap: 8px; 
            padding: 15px 10px; 
            background: rgba(255,255,255,0.03); 
            border-radius: 20px; 
            min-height: 100px; 
            margin-bottom: 15px; 
            border: 1px solid #333;
            flex-wrap: wrap;
            max-width: 600px;
            margin-left: auto;
            margin-right: auto;
        }
        .slot { 
            width: 70px; 
            height: 85px; 
            border: 2px dashed #444; 
            border-radius: 12px; 
            display: flex; 
            align-items: center; 
            justify-content: center; 
            cursor: pointer; 
            transition: 0.2s;
            font-size: 1.5rem; 
            color: #555;
        }
        .slot.active { 
            border-style: solid; 
            border-color: #00f3ff; 
            background: rgba(0, 243, 255, 0.1); 
            box-shadow: 0 0 12px #00f3ff;
            animation: pulse 2s infinite;
        }
        .slot img { width: 100%; height: 100%; object-fit: contain; }
        
        @keyframes pulse { 
            0%, 100% { box-shadow: 0 0 8px #00f3ff; } 
            50% { box-shadow: 0 0 18px #00f3ff; } 
        }
        
        /* Palette */
        .palette { 
            display: grid; 
            grid-template-columns: repeat(auto-fill, minmax(75px, 1fr)); 
            gap: 8px; 
            max-width: 600px; 
            margin: 0 auto; 
            padding: 10px;
        }
        .cat-header { 
            grid-column: 1 / -1; 
            text-align: left; 
            font-size: 12px; 
            color: #888; 
            text-transform: uppercase; 
            margin-top: 10px; 
            padding-bottom: 5px;
            border-bottom: 1px solid #333;
        }
        .char-box { 
            background: rgba(255,255,255,0.08); 
            padding: 8px 5px; 
            border-radius: 10px; 
            cursor: pointer; 
            transition: 0.15s; 
            border: 2px solid transparent;
            border-bottom-width: 3px;
        }
        .char-box:active { transform: scale(0.95); background: rgba(255,255,255,0.15); }
        .char-box img { 
            width: 45px; 
            height: 45px; 
            object-fit: contain; 
            pointer-events: none; 
        }
        .char-label { 
            font-size: 9px; 
            color: #aaa; 
            display: block; 
            margin-top: 4px; 
            font-weight: 600;
            text-transform: uppercase;
        }
        
        /* Loading State */
        .loading { 
            padding: 40px; 
            color: #666; 
        }
        .error { 
            padding: 20px; 
            color: #e74c3c; 
            background: rgba(231,76,60,0.1); 
            border-radius: 10px; 
            margin: 20px;
        }
        
        /* Landscape tweaks */
        @media (orientation: landscape) and (max-height: 500px) {
            h1 { font-size: 1.2rem; margin: 5px 0 10px; }
            .btn-ctrl { width: 55px; height: 55px; font-size: 1.5rem; }
            .stage { min-height: 80px; padding: 10px; }
            .slot { width: 55px; height: 70px; }
        }
    </style>
</head>
<body>
    <h1>S4K Mixer</h1>
    
    <div class="controls">
        <button id="playBtn" class="btn-ctrl btn-play">▶</button>
        <button id="stopBtn" class="btn-ctrl btn-stop">■</button>
    </div>
    
    <div class="stage" id="stage">
        <div class="loading">Loading...</div>
    </div>
    
    <div id="palette" class="palette">
        <div class="loading">Loading characters...</div>
    </div>

    <script>
        // S4K V2 - Config-Driven Mixer
        // Add new characters by editing config.json only!
        
        let config = null;
        let audioCtx = null;
        const activeSources = {};
        let isPlaying = false;
        const SLOT_COUNT = 7;
        
        // Initialize
        async function init() {
            try {
                // Load config
                const response = await fetch('./config.json');
                if (!response.ok) throw new Error('Config not found');
                config = await response.json();
                
                // Build UI
                buildStage();
                buildPalette();
                setupControls();
                
                console.log(`S4K V2 loaded: ${config.characters.length} characters`);
            } catch (err) {
                console.error('Init error:', err);
                document.getElementById('stage').innerHTML = 
                    `<div class="error">Error loading config.json<br><small>${err.message}</small></div>`;
                document.getElementById('palette').innerHTML = '';
            }
        }
        
        function buildStage() {
            const stage = document.getElementById('stage');
            stage.innerHTML = '';
            for (let i = 0; i < SLOT_COUNT; i++) {
                const slot = document.createElement('div');
                slot.className = 'slot';
                slot.id = `slot-${i}`;
                slot.textContent = '+';
                slot.onclick = () => removeFromSlot(i);
                stage.appendChild(slot);
            }
        }
        
        function buildPalette() {
            const palette = document.getElementById('palette');
            palette.innerHTML = '';
            
            // Group by category
            const byType = {};
            config.characters.forEach(char => {
                if (!byType[char.type]) byType[char.type] = [];
                byType[char.type].push(char);
            });
            
            // Render each category
            config.categories.forEach(cat => {
                if (!byType[cat.id]) return;
                
                // Header
                const header = document.createElement('div');
                header.className = 'cat-header';
                header.textContent = cat.label;
                header.style.borderBottomColor = cat.color;
                palette.appendChild(header);
                
                // Characters
                byType[cat.id].forEach(char => {
                    const box = document.createElement('div');
                    box.className = 'char-box';
                    box.style.borderBottomColor = cat.color;
                    box.innerHTML = `
                        <img src="${config.paths.img}${char.img}" alt="${char.id}">
                        <span class="char-label">${char.id}</span>
                    `;
                    box.onclick = () => addToStage(char);
                    palette.appendChild(box);
                });
            });
        }
        
        function setupControls() {
            document.getElementById('playBtn').onclick = togglePlay;
            document.getElementById('stopBtn').onclick = clearStage;
        }
        
        function getAudioContext() {
            if (!audioCtx) {
                audioCtx = new (window.AudioContext || window.webkitAudioContext)();
            }
            if (audioCtx.state === 'suspended') {
                audioCtx.resume();
            }
            return audioCtx;
        }
        
        function togglePlay() {
            const ctx = getAudioContext();
            isPlaying = !isPlaying;
            
            const btn = document.getElementById('playBtn');
            if (isPlaying) {
                btn.textContent = '⏸';
                btn.classList.add('playing');
                ctx.resume();
            } else {
                btn.textContent = '▶';
                btn.classList.remove('playing');
                ctx.suspend();
            }
        }
        
        async function addToStage(char) {
            const ctx = getAudioContext();
            
            // Find empty slot
            const slots = document.querySelectorAll('.slot');
            let emptySlot = null;
            for (const slot of slots) {
                if (slot.textContent === '+') {
                    emptySlot = slot;
                    break;
                }
            }
            if (!emptySlot) return; // Stage full
            
            // Visual update
            emptySlot.innerHTML = `<img src="${config.paths.img}${char.img}" alt="${char.id}">`;
            emptySlot.classList.add('active');
            emptySlot.dataset.charId = char.id;
            
            // Load and play audio
            try {
                const audioUrl = `${config.paths.audio}${char.audio}`;
                const response = await fetch(audioUrl);
                if (!response.ok) throw new Error(`HTTP ${response.status}`);
                
                const arrayBuffer = await response.arrayBuffer();
                const audioBuffer = await ctx.decodeAudioData(arrayBuffer);
                
                const source = ctx.createBufferSource();
                source.buffer = audioBuffer;
                source.loop = true;
                source.connect(ctx.destination);
                source.start(0);
                
                activeSources[emptySlot.id] = source;
                
                // Sync with play state
                if (!isPlaying) ctx.suspend();
                
            } catch (err) {
                console.error(`Audio load failed: ${char.audio}`, err);
                emptySlot.innerHTML = '❌';
                emptySlot.classList.remove('active');
            }
        }
        
        function removeFromSlot(index) {
            const slotId = `slot-${index}`;
            const slot = document.getElementById(slotId);
            
            // Stop audio
            if (activeSources[slotId]) {
                activeSources[slotId].stop();
                delete activeSources[slotId];
            }
            
            // Reset visual
            slot.innerHTML = '+';
            slot.classList.remove('active');
            delete slot.dataset.charId;
        }
        
        function clearStage() {
            for (let i = 0; i < SLOT_COUNT; i++) {
                removeFromSlot(i);
            }
            isPlaying = false;
            const btn = document.getElementById('playBtn');
            btn.textContent = '▶';
            btn.classList.remove('playing');
            if (audioCtx) audioCtx.resume();
        }
        
        // Start
        init();
    </script>
</body>
</html>
